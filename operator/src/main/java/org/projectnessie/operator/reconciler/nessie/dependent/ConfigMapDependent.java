/*
 * Copyright (C) 2024 Dremio
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.projectnessie.operator.reconciler.nessie.dependent;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.projectnessie.operator.events.EventReason.CreatingConfigMap;

import com.fasterxml.jackson.databind.JsonNode;
import io.fabric8.kubernetes.api.model.ConfigMap;
import io.fabric8.kubernetes.api.model.ConfigMapBuilder;
import io.javaoperatorsdk.operator.api.reconciler.Context;
import io.javaoperatorsdk.operator.processing.dependent.kubernetes.CRUDKubernetesDependentResource;
import io.javaoperatorsdk.operator.processing.dependent.kubernetes.KubernetesDependent;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.TreeMap;
import org.bouncycastle.util.encoders.Hex;
import org.projectnessie.operator.events.EventService;
import org.projectnessie.operator.reconciler.KubernetesHelper;
import org.projectnessie.operator.reconciler.nessie.NessieReconciler;
import org.projectnessie.operator.reconciler.nessie.resource.Nessie;
import org.projectnessie.operator.reconciler.nessie.resource.NessieSpec.LogLevel;
import org.projectnessie.operator.reconciler.nessie.resource.options.AuthorizationOptions;
import org.projectnessie.operator.reconciler.nessie.resource.options.BigTableOptions;
import org.projectnessie.operator.reconciler.nessie.resource.options.CassandraOptions;
import org.projectnessie.operator.reconciler.nessie.resource.options.DynamoDbOptions;
import org.projectnessie.operator.reconciler.nessie.resource.options.JdbcOptions;
import org.projectnessie.operator.reconciler.nessie.resource.options.JdbcOptions.DataSource;
import org.projectnessie.operator.reconciler.nessie.resource.options.MongoDbOptions;
import org.projectnessie.operator.reconciler.nessie.resource.options.VersionStoreCacheOptions;
import org.projectnessie.operator.reconciler.nessie.resource.options.VersionStoreOptions;
import org.projectnessie.operator.reconciler.nessie.resource.options.VersionStoreOptions.VersionStoreType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@KubernetesDependent(labelSelector = NessieReconciler.DEPENDENT_RESOURCES_SELECTOR)
public class ConfigMapDependent extends CRUDKubernetesDependentResource<ConfigMap, Nessie> {

  private static final Logger LOGGER = LoggerFactory.getLogger(ConfigMapDependent.class);

  private static final long MIB = 1024L * 1024L;

  private static final String FILE_HEADER =
      """
      # Automatically generated by the Nessie Kubernetes Operator
      # DO NOT EDIT

      """;

  public ConfigMapDependent() {
    super(ConfigMap.class);
  }

  @Override
  public ConfigMap create(ConfigMap desired, Nessie nessie, Context<Nessie> context) {
    LOGGER.debug(
        "Creating config-map {} for {}",
        desired.getMetadata().getName(),
        nessie.getMetadata().getName());
    EventService eventService = EventService.retrieveFromContext(context);
    eventService.fireEvent(
        nessie, CreatingConfigMap, "Creating config-map %s", desired.getMetadata().getName());
    return super.create(desired, nessie, context);
  }

  @Override
  public ConfigMap desired(Nessie nessie, Context<Nessie> context) {
    KubernetesHelper helper = KubernetesHelper.retrieveFromContext(context);
    return new ConfigMapBuilder()
        .withMetadata(helper.metaBuilder(nessie).build())
        .addToData("application.properties", FILE_HEADER + configAsProperties(nessie))
        .build();
  }

  private static Map<String, String> collectConfig(Nessie nessie) {
    Map<String, String> config = new TreeMap<>();
    configureLogLevel(nessie, config);
    configureVersionStore(nessie, config);
    configureAuthentication(nessie, config);
    configureAuthorization(nessie, config);
    configureTelemetry(nessie, config);
    configureAdvancedConfig(nessie, config);
    return config;
  }

  public static String configChecksum(Nessie nessie) {
    Map<String, String> config = collectConfig(nessie);
    MessageDigest digest;
    try {
      digest = MessageDigest.getInstance("SHA-256");
    } catch (NoSuchAlgorithmException e) {
      throw new RuntimeException(e);
    }
    config.forEach(
        (k, v) -> {
          digest.update(k.getBytes(UTF_8));
          digest.update(v.getBytes(UTF_8));
        });
    String checksum = new String(Hex.encode(digest.digest()));
    return "sha256:" + checksum;
  }

  private static String configAsProperties(Nessie nessie) {
    Map<String, String> config = collectConfig(nessie);
    StringBuilder sb = new StringBuilder();
    config.forEach((k, v) -> sb.append(k).append("=").append(v).append("\n"));
    return sb.toString();
  }

  private static void configureLogLevel(Nessie nessie, Map<String, String> config) {
    LogLevel logLevel = nessie.getSpec().logLevel();
    if (logLevel != LogLevel.INFO) {
      config.put("quarkus.log.level", logLevel.name());
    }
    if (logLevel.compareTo(LogLevel.INFO) < 0) {
      config.put("quarkus.log.console.level", logLevel.name());
      config.put("quarkus.log.file.level", logLevel.name());
    }
  }

  private static void configureAuthentication(Nessie nessie, Map<String, String> config) {
    if (nessie.getSpec().authentication().enabled()) {
      config.put("nessie.server.authentication.enabled", "true");
      String oidcAuthServerUrl = nessie.getSpec().authentication().oidcAuthServerUrl();
      config.put("quarkus.oidc.auth-server-url", oidcAuthServerUrl);
      String oidcClientId = nessie.getSpec().authentication().oidcClientId();
      config.put("quarkus.oidc.client-id", oidcClientId);
    } else {
      config.put("quarkus.oidc.tenant-enabled", "false");
    }
  }

  private static void configureAuthorization(Nessie nessie, Map<String, String> config) {
    AuthorizationOptions authorization = nessie.getSpec().authorization();
    if (authorization.enabled()) {
      config.put("nessie.server.authorization.enabled", "true");
      authorization
          .rules()
          .forEach((key, value) -> config.put("nessie.server.authorization.rules." + key, value));
    }
  }

  private static void configureTelemetry(Nessie nessie, Map<String, String> config) {
    if (nessie.getSpec().telemetry().enabled()) {
      String endpoint = nessie.getSpec().telemetry().endpoint();
      config.put("quarkus.otel.exporter.otlp.traces.endpoint", endpoint);
      Map<String, String> attributes =
          new LinkedHashMap<>(nessie.getSpec().telemetry().attributes());
      attributes.putIfAbsent("service.name", nessie.getMetadata().getName());
      String attributesStr =
          attributes.entrySet().stream()
              .map(e -> e.getKey() + "=" + e.getValue())
              .reduce((a, b) -> a + "," + b)
              .orElse("");
      config.put("quarkus.otel.resource.attributes", attributesStr);
      String sample = nessie.getSpec().telemetry().sample();
      if (sample != null && !sample.isEmpty()) {
        switch (sample) {
          case "all" -> config.put("quarkus.otel.traces.sampler", "parentbased_always_on");
          case "none" -> config.put("quarkus.otel.traces.sampler", "parentbased_always_off");
          default -> {
            config.put("quarkus.otel.traces.sampler", "parentbased_traceidratio");
            config.put("quarkus.otel.traces.sampler.arg", sample);
          }
        }
      }
    } else {
      config.put("quarkus.otel.sdk.disabled", "true");
    }
  }

  private static void configureVersionStore(Nessie nessie, Map<String, String> config) {
    VersionStoreOptions versionStore = nessie.getSpec().versionStore();
    configureVersionStoreCache(nessie, config);
    VersionStoreType type = versionStore.type();
    switch (type) {
      case InMemory -> {}
      case RocksDb -> configureRocks(config);
      case Jdbc -> configureJdbc(nessie, config);
      case BigTable -> configureBigTable(nessie, config);
      case MongoDb -> configureMongo(nessie, config);
      case Cassandra -> configureCassandra(nessie, config);
      case DynamoDb -> configureDynamo(nessie, config);
      default -> throw new AssertionError("Unexpected version store type: " + type);
    }
  }

  private static void configureVersionStoreCache(Nessie nessie, Map<String, String> config) {
    VersionStoreCacheOptions cache = nessie.getSpec().versionStore().cache();
    if (cache.enabled()) {
      if (cache.fixedSize() != null) {
        long mb = cache.fixedSize().getNumericalAmount().longValue() / MIB;
        config.put("nessie.version.store.persist.cache-capacity-mb", String.valueOf(mb));
      } else {
        if (!cache.heapFraction().equals(VersionStoreCacheOptions.DEFAULT_HEAP_PERCENTAGE)) {
          double hf = cache.heapFraction().getNumericalAmount().doubleValue();
          config.put(
              "nessie.version.store.persist.cache-capacity-fraction-of-heap", String.valueOf(hf));
        }
        if (!cache.minSize().equals(VersionStoreCacheOptions.DEFAULT_MIN_SIZE)) {
          long ms = cache.minSize().getNumericalAmount().longValue() / MIB;
          config.put(
              "nessie.version.store.persist.cache-capacity-fraction-min-size-mb",
              String.valueOf(ms));
        }
        if (!cache.minFreeHeap().equals(VersionStoreCacheOptions.DEFAULT_MIN_FREE_HEAP)) {
          long mfh = cache.minFreeHeap().getNumericalAmount().longValue() / MIB;
          config.put(
              "nessie.version.store.persist.cache-capacity-fraction-adjust-mb",
              String.valueOf(mfh));
        }
      }
    } else {
      config.put("nessie.version.store.persist.cache-capacity-mb", "0");
    }
  }

  private static void configureRocks(Map<String, String> config) {
    config.put("nessie.version.store.type", "ROCKSDB");
    config.put(
        "nessie.version.store.persist.rocks.database-path", DeploymentDependent.ROCKS_MOUNT_PATH);
  }

  private static void configureJdbc(Nessie nessie, Map<String, String> config) {
    JdbcOptions jdbc = Objects.requireNonNull(nessie.getSpec().versionStore().jdbc());
    config.put("nessie.version.store.type", "JDBC");
    DataSource datasource = jdbc.datasource();
    config.put("nessie.version.store.persist.jdbc.datasource", datasource.name());
    config.put(datasource.configPrefix() + "jdbc.url", jdbc.url());
    if (jdbc.username() != null) {
      config.put(datasource.configPrefix() + "username", jdbc.username());
    }
  }

  private static void configureBigTable(Nessie nessie, Map<String, String> config) {
    BigTableOptions bigTable = Objects.requireNonNull(nessie.getSpec().versionStore().bigTable());
    config.put("nessie.version.store.type", "BIGTABLE");
    config.put("quarkus.google.cloud.project-id", bigTable.projectId());
    config.put("nessie.version.store.persist.bigtable.instance-id", bigTable.instanceId());
    config.put("nessie.version.store.persist.bigtable.app-profile-id", bigTable.appProfileId());
  }

  private static void configureMongo(Nessie nessie, Map<String, String> config) {
    MongoDbOptions mongoDb = Objects.requireNonNull(nessie.getSpec().versionStore().mongoDb());
    config.put("nessie.version.store.type", "MONGODB");
    config.put("quarkus.mongodb.connection-string", mongoDb.connectionString());
    config.put("quarkus.mongodb.database", mongoDb.database());
    if (mongoDb.username() != null) {
      config.put("quarkus.mongodb.credentials.username", mongoDb.username());
    }
  }

  private static void configureCassandra(Nessie nessie, Map<String, String> config) {
    CassandraOptions cassandra =
        Objects.requireNonNull(nessie.getSpec().versionStore().cassandra());
    config.put("nessie.version.store.type", "CASSANDRA");
    config.put("quarkus.cassandra.keyspace", cassandra.keyspace());
    config.put(
        "quarkus.cassandra.contact-points",
        cassandra.contactPoints().stream().reduce((a, b) -> a + "," + b).orElse(""));
    config.put("quarkus.cassandra.local-datacenter", cassandra.localDatacenter());
    if (cassandra.username() != null) {
      config.put("quarkus.cassandra.auth.username", cassandra.username());
    }
  }

  private static void configureDynamo(Nessie nessie, Map<String, String> config) {
    DynamoDbOptions dynamoDb = Objects.requireNonNull(nessie.getSpec().versionStore().dynamoDb());
    config.put("nessie.version.store.type", "DYNAMODB");
    config.put("quarkus.dynamodb.aws.region", dynamoDb.region());
  }

  private static void configureAdvancedConfig(Nessie nessie, Map<String, String> config) {
    JsonNode advancedConfig = nessie.getSpec().advancedConfig();
    if (advancedConfig != null && !advancedConfig.isEmpty()) {
      applyAdvancedConfig(config, advancedConfig, "");
    }
  }

  private static void applyAdvancedConfig(
      Map<String, String> config, JsonNode configNode, String prefix) {
    for (Map.Entry<String, JsonNode> entry : configNode.properties()) {
      String key = prefix + entry.getKey();
      JsonNode value = entry.getValue();
      if (value.isObject()) {
        applyAdvancedConfig(config, value, key + ".");
      } else {
        assert value.isValueNode(); // already validated
        config.put(key, value.asText());
      }
    }
  }
}
